def count_path():
    
    n, m = 6, 6
    #通れないところを定義
    blocked = {(2, 2), (5, 1)}
    dp = [[0] * m for _ in range(n)]

    #dpの初期化、左下のスタート地点を１とする
    dp[0][0] = 1

    for i in range(n):
        for j in range(m):
            if (i, j)not in blocked:#通れる場所だったら
                if i - 1 >= 0:#枠内に収まるように
                    dp[i][j] += dp[i-1][j]            
                if j - 1 >= 0:#枠内に収まるように
                     dp[i][j] += dp[i][j-1]

    return dp[-1][-1]
    #Pythonのリストは、負のインデックスを使用して後ろから要素にアクセスすることができます。
    #例えば、リスト`dp`の最後の要素にアクセスする場合、`dp[-1]`と書くことで最後の要素にアクセスできます。
    #`dp[-2]`は最後から2番目の要素にアクセスし、以降も同様です。
    #このような負のインデックスを使うことで、リストの後ろから要素にアクセスする際に便利です。
    #`dp[-1]`は`dp[len(dp) - 1]`と等価で、リストの最後の要素を取得する方法です

print(count_path())